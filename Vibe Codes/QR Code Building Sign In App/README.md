**Project Overview**
The Access Control App is a comprehensive building access control and audit system designed to meet the stringent security requirements for organizations pursuing CREST Security Operations Centre (SOC) certification. This full-stack web application provides a robust solution for tracking personnel movement within secure facilities, maintaining detailed audit logs, and ensuring compliance with security protocols. Built with modern web technologies and security best practices, the system serves as both a practical access control tool and a demonstration of enterprise-level security implementation suitable for organizations handling sensitive data and requiring comprehensive audit trails.

**Problem Statement and Solution**
Modern security-conscious organizations face the challenge of maintaining accurate, real-time records of personnel access to secure facilities while ensuring compliance with industry standards such as CREST SOC certification requirements. Traditional sign-in sheets and manual logging systems are prone to errors, difficult to audit, and fail to provide the granular tracking necessary for security compliance. This application addresses these challenges by providing an automated, QR code-based access control system that captures comprehensive audit data including timestamps, user identification, IP addresses, and user agent information. The system ensures that every access event is logged immutably, providing security teams with the forensic data necessary for incident investigation and compliance audits.

**Core Features and User Experience**
The application provides a streamlined user experience centered around quick and efficient building access status management. Users authenticate through the system using either traditional email-password credentials or as guest users with just their first and last names, making it adaptable to various organizational needs including temporary contractors or visitors. Once authenticated, users access a clean, intuitive dashboard displaying their current building access status with clear visual indicators showing whether they are currently signed in or signed out of the facility. The dashboard employs a modern design with the Evalian brand color scheme featuring purple and cyan accents, creating a professional interface that is both aesthetically pleasing and highly functional.

**QR Code Integration and Mobile Functionality**
A cornerstone feature of the application is its sophisticated QR code scanning system that enables seamless access control. The system generates a unique building access QR code that can be printed and placed at facility entry and exit points. Users can scan this QR code using either their mobile device camera or the built-in web-based QR scanner to instantly toggle their building access status. This approach eliminates the need for physical access cards or manual sign-in procedures, reducing friction in the access process while maintaining comprehensive audit trails. The QR code implementation uses the device's camera API with proper error handling and permission management, ensuring reliability across different browsers and devices. The system validates scanned codes in real-time and provides immediate feedback to users through toast notifications, confirming successful status changes or alerting them to invalid codes.

**Authentication Architecture and Session Management**
The authentication system is built on NextAuth.js, providing a secure, industry-standard authentication solution with support for both traditional user accounts and guest access patterns. Regular users register using invite codes—a security measure that prevents unauthorized account creation—and authenticate with email and password credentials that are hashed using bcrypt with appropriate salt rounds. The system implements secure session management using HTTP-only cookies, protecting session tokens from client-side JavaScript access and reducing the risk of XSS-based session hijacking. Guest users receive a separate authentication flow that issues temporary session cookies without requiring email addresses, allowing for flexible access control while maintaining comprehensive audit logging. All authentication events, including successful logins, failed attempts, and logouts, are captured in the audit log with associated metadata such as IP addresses and user agents for security monitoring and forensic analysis.

**Administrative Capabilities and Monitoring**
The administrative interface provides security personnel and facility managers with comprehensive oversight of building access activities. Administrators access a dedicated dashboard that displays real-time status of all users in the system, showing who is currently signed in to the facility and when each access event occurred. The admin panel includes powerful filtering capabilities that allow security teams to view activities by date range, user type (regular or guest), action type (sign-ins, sign-outs, account creations), and specific users. This granular filtering enables rapid investigation of security incidents and efficient compliance reporting. The system provides CSV export functionality, allowing administrators to extract audit logs for integration with external security information and event management (SIEM) systems or for archival purposes. The admin dashboard displays key metrics including total user counts, current occupancy levels, and recent activity summaries, providing at-a-glance situational awareness of facility access patterns.

**Invite Code System and Access Control**
To maintain strict control over who can create accounts in the system, the application implements a secure invite code mechanism. Administrators can generate unique invite codes through the admin interface, with each code being cryptographically random and associated with metadata including creation timestamp and usage status. When new users attempt to register, they must provide a valid, unused invite code to complete account creation. The system validates the invite code in real-time and marks it as used upon successful registration, preventing code reuse. This approach provides a balance between security and usability—organizations can pre-generate codes for expected new hires or contractors, distribute them through secure channels, and maintain an audit trail of which codes were used by which users. The system includes a code management interface where administrators can view all generated codes, their usage status, and reset codes if necessary.

**Security Features and Rate Limiting**
Security is paramount in an access control system, and this application implements multiple layers of protection against common attack vectors. The system employs rate limiting on critical endpoints such as login attempts, status toggles, and invite code generation to prevent brute force attacks and abuse. The rate limiting implementation uses an in-memory store that tracks requests by IP address and user identifier, with configurable limits and time windows that can be adjusted based on organizational security policies. All password fields implement proper hashing algorithms, and the system enforces HTTPS in production environments to protect credentials in transit. The application follows the principle of least privilege, with clear role separation between regular users and administrators. Input validation is implemented at both client and server levels, with sanitization of user-provided data to prevent SQL injection and XSS attacks. The system logs all security-relevant events, including failed authentication attempts, which can trigger automated alerts in production deployments.

**Technology Stack and Modern Architecture**
The application is built on Next.js 14 using the App Router architecture, leveraging React Server Components for optimal performance and reduced client-side JavaScript. The frontend utilizes TypeScript for type safety and improved developer experience, with comprehensive type definitions throughout the codebase. The UI is constructed using Radix UI primitives and styled with Tailwind CSS, providing a component library that is both accessible and customizable. The application uses React Hook Form with Zod validation for client-side form handling, ensuring robust validation before data reaches the server. Chart.js and Recharts power the data visualization components in the admin dashboard, presenting audit data in easily digestible visual formats. The tech stack includes next-themes for dark mode support, Lucide React for consistent iconography, and Framer Motion for smooth animations that enhance the user experience without compromising performance.

**Database Schema and Data Persistence**
The application uses PostgreSQL as its relational database, accessed through Prisma ORM for type-safe database queries and migrations. The database schema is carefully designed to support the application's audit requirements while maintaining performance and scalability. The User model stores authentication credentials, profile information, and current access status, with support for both regular and guest account types. The Log model maintains a comprehensive audit trail, capturing every significant event in the system with associated metadata including user IDs, action types, timestamps, IP addresses, and user agent strings. This audit log is designed to be write-only in normal operations, preserving data integrity for compliance purposes. The schema includes an InviteCode model that manages the invite code lifecycle, tracking which codes have been used and by whom. Prisma's migration system ensures that database schema changes are versioned and applied consistently across development, staging, and production environments. The database configuration includes connection pooling and appropriate indexes on frequently queried fields to maintain performance as the audit log grows over time.

**API Architecture and Server-Side Logic**
The backend architecture follows RESTful API principles, with clearly defined endpoints for each operation exposed through Next.js API routes. The authentication flow is handled through NextAuth's dynamic API route at /api/auth/[...nextauth], which manages OAuth flows, session creation, and credential validation. Custom API routes handle specific application logic, including user registration at /api/signup, guest authentication at /api/auth/guest-login, and status management at /api/user/toggle-status. The admin functionality is exposed through dedicated endpoints such as /api/admin/generate-invite for invite code creation and /api/admin/export-logs for audit log exports. Each API route implements proper error handling with appropriate HTTP status codes, and includes authentication checks using getServerSession to ensure only authorized users can access protected resources. The server-side code validates all inputs, sanitizes data before database insertion, and implements rate limiting through a custom middleware layer. Database operations use Prisma transactions where appropriate to ensure data consistency, particularly when multiple related records must be created or updated atomically.

**Backend Code Structure and Best Practices**
The backend codebase is organized following separation of concerns principles, with distinct modules for authentication logic, database access, rate limiting, and utility functions. The lib/auth.ts file contains the NextAuth configuration including credential providers, session callbacks, and JWT handling. Custom authentication logic for guest users is implemented with secure session token generation using cryptographic random values. The lib/db.ts module provides a singleton Prisma client instance with appropriate configuration for connection pooling and query optimization. Rate limiting logic is abstracted into lib/rate-limiter.ts, implementing a flexible system that can be applied to any endpoint requiring throttling. Type definitions are centralized in lib/types.ts, providing shared interfaces used across both client and server code to ensure type consistency. The backend implements comprehensive error logging, with structured error messages that aid in debugging while avoiding exposure of sensitive implementation details to clients. Database queries are optimized to minimize N+1 problems through Prisma's include and select options, and the codebase follows async/await patterns consistently for cleaner error handling. The server-side code includes proper cleanup of resources, with database connection management and session cleanup handled through Next.js lifecycle hooks. All environment variables are properly typed and validated at application startup, preventing runtime errors due to misconfiguration.

**Deployment and Production Considerations**
The application is designed for production deployment with security and reliability in mind. Environment variables manage sensitive configuration including database connection strings, NextAuth secrets, and API keys, with different configurations for development, staging, and production environments. The build process generates optimized static pages where possible, with server-side rendering for dynamic content requiring authentication. The application includes comprehensive error boundaries and fallback UI to ensure graceful degradation when errors occur. Logging is structured to support integration with monitoring tools such as Datadog or Sentry, enabling proactive identification of issues in production. The database migration strategy uses Prisma's migration system with proper versioning, allowing for safe schema updates without data loss. The application supports horizontal scaling through stateless server-side code, with session data stored in the database rather than in-memory, allowing multiple application instances to serve requests without session affinity requirements. The system is designed to handle high traffic volumes through efficient database queries, connection pooling, and appropriate caching strategies for frequently accessed but rarely changing data.
